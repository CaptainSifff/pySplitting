---

title: pySplitting

keywords: fastai
sidebar: home_sidebar

summary: "This is a port of the Mathematica script to python3."
description: "This is a port of the Mathematica script to python3."
nb_path: "00_core.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="findpos" class="doc_header"><code>findpos</code><a href="__main__.py#L9" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>findpos</code>(<strong><code>lam</code></strong>)</p>
</blockquote>
<p>This determines whether the index string is a strictly ascending sequence.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>lam : an indexable object of things that are comparable. Usually an array of integers</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>bool : the position in the string where two ints are equal.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="isstrictlyascending" class="doc_header"><code>isstrictlyascending</code><a href="https://github.com/CaptainSifff/pySplitting/tree/master/pySplitting/core.py#L37" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>isstrictlyascending</code>(<strong><code>lam</code></strong>)</p>
</blockquote>
<p>This determines whether the index string is a strictly ascending sequence</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>lam : an indexable object of things that are comparable. Usually an array of integers</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>bool : true if the sequence is strictly ascending, else false.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="alpha" class="doc_header"><code>alpha</code><a href="https://github.com/CaptainSifff/pySplitting/tree/master/pySplitting/core.py#L62" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>alpha</code>(<strong><code>lam</code></strong>)</p>
</blockquote>
<p>The alpha factor
This determines the real alpha coefficient as given by Thalhammer and elaborated by Blanes.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>lam : A multiindex</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>Rational: alpha(lam)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">alpha</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="CreateMuVectors" class="doc_header"><code>CreateMuVectors</code><a href="https://github.com/CaptainSifff/pySplitting/tree/master/pySplitting/core.py#L82" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>CreateMuVectors</code>(<strong><code>p</code></strong>, <strong><code>k</code></strong>)</p>
</blockquote>
<p>This function creates the set of possible $$\mu$$ vectors.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>p : the considered order
k : 1 &lt;=k&lt;=p</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>array : A list of multiindices</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="CreateLyndonIndices" class="doc_header"><code>CreateLyndonIndices</code><a href="https://github.com/CaptainSifff/pySplitting/tree/master/pySplitting/core.py#L102" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>CreateLyndonIndices</code>(<strong><code>p</code></strong>, <strong><code>k</code></strong>)</p>
</blockquote>
<p>This function creates the set of Lyndon indices</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>p : the considered order
k : 1 &lt;=k&lt;=p</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>array : A list of Lyndon multiindices</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="CreateEquation" class="doc_header"><code>CreateEquation</code><a href="https://github.com/CaptainSifff/pySplitting/tree/master/pySplitting/core.py#L139" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>CreateEquation</code>(<strong><code>mu</code></strong>, <strong><code>bvec</code></strong>, <strong><code>cvec</code></strong>)</p>
</blockquote>
<p>This function gives the coefficient for a particular multiindex mu.
   It is the coefficient of a Len (mu) long product of iterated
   commutators [A, B]_(mu_k).</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2>
<pre><code>mu : a multiindex
bvec : a string of symbols
cvec : a string of symbols(usually the partial sums of the avec)

Returns
-------
expr : a symbolic expression, a polynomial in terms of the contents of bvec and cvec</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="CreateConditions" class="doc_header"><code>CreateConditions</code><a href="__main__.py#L5" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>CreateConditions</code>(<strong><code>p</code></strong>, <strong><code>avec</code></strong>, <strong><code>bvec</code></strong>, <strong><code>indexgenerator</code></strong>=<em><code>'CreateLyndonIndices'</code></em>)</p>
</blockquote>
<p>This creates the set of equations using by default the Lyndon Basis elements.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>p : the considered order
avec: The set of symbols to use for the first operator.
bvec: The set of symbols to use for the second operator.
indexgenerator: (optional) by default we use indexgenerator for the Lyndon indices. Using CreateMuVectors
                 the indices from the overcomplete Hall-Basis can be used.</p>
<h2 id="Returns">Returns<a class="anchor-link" href="#Returns"> </a></h2><p>array : An array of Equations that have to be satisfied to fulfill the requested order p.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">avec</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">symarray</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">bvec</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">symarray</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">CreateConditions</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=========================&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">CreateConditions</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="p">,</span><span class="n">CreateMuVectors</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[Eq(a_0 + a_1 + a_2, 1), Eq(-b_0 - b_1 - b_2 + 1, 0), Eq(-a_0*b_0 - b_1*(a_0 + a_1) - b_2 + 1/2, 0), Eq(-a_0**2*b_0 - b_1*(a_0 + a_1)**2 - b_2 + 1/3, 0), Eq(-a_0*b_0**2/2 - a_0*b_0*b_1 - a_0*b_0*b_2 - b_1**2*(a_0 + a_1)/2 - b_1*b_2*(a_0 + a_1) - b_2**2/2 + 1/6, 0)]
=========================
[Eq(a_0 + a_1 + a_2, 1), Eq(-b_0 - b_1 - b_2 + 1, 0), Eq(-a_0*b_0 - b_1*(a_0 + a_1) - b_2 + 1/2, 0), Eq(-a_0**2*b_0 - b_1*(a_0 + a_1)**2 - b_2 + 1/3, 0), Eq(-b_0**2/2 - b_0*b_1 - b_0*b_2 - b_1**2/2 - b_1*b_2 - b_2**2/2 + 1/2, 0), Eq(-a_0*b_0**2/2 - a_0*b_0*b_1 - a_0*b_0*b_2 - b_1**2*(a_0 + a_1)/2 - b_1*b_2*(a_0 + a_1) - b_2**2/2 + 1/6, 0), Eq(-a_0*b_0**2/2 - b_0*b_1*(a_0 + a_1) - b_0*b_2 - b_1**2*(a_0 + a_1)/2 - b_1*b_2 - b_2**2/2 + 1/3, 0), Eq(-b_0**3/6 - b_0**2*b_1/2 - b_0**2*b_2/2 - b_0*b_1**2/2 - b_0*b_1*b_2 - b_0*b_2**2/2 - b_1**3/6 - b_1**2*b_2/2 - b_1*b_2**2/2 - b_2**3/6 + 1/6, 0)]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

